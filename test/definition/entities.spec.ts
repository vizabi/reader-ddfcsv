import * as chai from 'chai';
import { getDDFCsvReaderObject } from '../../src/index';
import * as Papa from 'papaparse';
import {
  BASE_PATH,
  checkExpectations,
  EXPECTS_EXACTLY_ONE_ERROR,
  getAmountOfErrors,
  notExpectedError,
  selectKeyClauseContainsUnavailableItems,
  selectKeyClauseMustHaveOnly1Item,
  selectValueClauseContainsUnavailableItems1,
  tooManyQueryDefinitionErrors,
  WS_TESTING_PATH
} from '../common';
import * as path from 'path';
import {
  CONCEPT_TYPE_ENTITY_DOMAIN,
  CONCEPT_TYPE_ENTITY_SET,
  isEntityDomainOrSet,
  RESERVED_CONCEPT,
  RESERVED_CONCEPT_TYPE,
  RESERVED_DOMAIN,
  RESERVED_DRILL_UP
} from '../../src/ddf-query-validator';
import * as fs from 'fs';
import isEmpty = require('lodash/isEmpty');
import head = require('lodash/head');
import map = require('lodash/map');
import filter = require('lodash/filter');

const expect = chai.expect;

describe('Entities definition errors in query', () => {
  describe('Autogenerated tests', () => {
    const ALL_CONCEPTS: string[] = [ '', ' ', RESERVED_CONCEPT, RESERVED_CONCEPT_TYPE, RESERVED_DOMAIN, RESERVED_DRILL_UP ];
    const ALL_OPERATORS: string[] = [ , '.', '.is--' ];
    const ALL_ENTITY_SETS_AND_DOMAINS: string[] = [];

    before((done: Function) => {
      const content = fs.readFileSync(path.resolve(BASE_PATH, WS_TESTING_PATH, 'master-HEAD', 'ddf--concepts.csv'), 'utf8');
      Papa.parse(content, {
        header: true,
        skipEmptyLines: true,
        complete(results) {
          if (!isEmpty(results.errors)) {
            return done(JSON.stringify(results.errors));
          }
          const conceptsNames: string[] = map(results.data, 'concept');
          const entitySetsAndDomains: string[] = filter(results.data, (concept) => isEntityDomainOrSet(concept.concept_type, [ CONCEPT_TYPE_ENTITY_DOMAIN, CONCEPT_TYPE_ENTITY_SET ]));
          const entitySetsAndDomainsNames: string[] = map(entitySetsAndDomains, 'concept');

          ALL_ENTITY_SETS_AND_DOMAINS.push(...entitySetsAndDomainsNames);
          ALL_CONCEPTS.push(...conceptsNames, head(ALL_ENTITY_SETS_AND_DOMAINS).substring(1));

          // console.log('All possible values: ', ALL_CONCEPTS.join(', '));
          // console.log('All possible sets&domains: ', ALL_ENTITY_SETS_AND_DOMAINS.join(', '));

          return done();
        }
      });
    });

    it('should be fine', (done: Function) => {
      // console.log('FFFFF');
      return done();
    });
  });

  describe('should be produced only for \'select\' section', () => {

    it('when \'key\' property has item that is absent in dataset', done => {
      const reader = getDDFCsvReaderObject();

      reader.init({ path: BASE_PATH });

      reader.read({
        select: {
          key: [ 'failed_concept' ],
          value: [ 'world_4region', 'un_state' ]
        },
        from: 'entities'
      })
        .then(() => done(notExpectedError))
        .catch(error => {

          expect(error).to.match(tooManyQueryDefinitionErrors);
          expect(getAmountOfErrors(error)).to.equals(EXPECTS_EXACTLY_ONE_ERROR);
          expect(error.toString()).to.match(selectKeyClauseContainsUnavailableItems);

          done();
        });
    });

    it('when \'key\' property has many items (structure error)', function(done: Function): void {
      const reader = getDDFCsvReaderObject();
      reader.init({ path: BASE_PATH });

      reader.read({
        from: 'entities', select: { key: [ 'geo', 'failed_concept' ] }
      })
        .then(() => done(notExpectedError))
        .catch(checkExpectations((error) => {
          // console.log(error.stack);
          expect(getAmountOfErrors(error)).to.equals(EXPECTS_EXACTLY_ONE_ERROR);
          expect(error.toString()).to.match(selectKeyClauseMustHaveOnly1Item);
        }, done));
    });

    it('when \'value\' property has items that is absent in dataset', function(done: Function): void {
      const reader = getDDFCsvReaderObject();
      reader.init({ path: BASE_PATH });

      reader.read({
        from: 'entities',
        select: {
          key: [ 'geo' ],
          value: [ 'failed_concept', 'world_4region', 'un_state', 'failed_concept2', 'population_total' ]
        }
      })
        .then(() => done(notExpectedError))
        .catch(checkExpectations((error) => {
          // console.log(error.stack);
          expect(error).to.match(tooManyQueryDefinitionErrors);
          expect(getAmountOfErrors(error)).to.equals(EXPECTS_EXACTLY_ONE_ERROR);
          expect(error.toString()).to.match(selectValueClauseContainsUnavailableItems1);
        }, done));
    });

  });
});
